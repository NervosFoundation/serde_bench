// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum SyncPayload {
  NONE = 0,
  GetHeaders = 1,
  Headers = 2,

}

pub const ENUM_MIN_SYNC_PAYLOAD: u8 = 0;
pub const ENUM_MAX_SYNC_PAYLOAD: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for SyncPayload {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for SyncPayload {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const SyncPayload;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const SyncPayload;
    unsafe { *p }
  }
}

impl flatbuffers::Push for SyncPayload {
    type Output = SyncPayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<SyncPayload>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SYNC_PAYLOAD:[SyncPayload; 3] = [
  SyncPayload::NONE,
  SyncPayload::GetHeaders,
  SyncPayload::Headers
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_SYNC_PAYLOAD:[&'static str; 3] = [
    "NONE",
    "GetHeaders",
    "Headers"
];

pub fn enum_name_sync_payload(e: SyncPayload) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_SYNC_PAYLOAD[index as usize]
}

pub struct SyncPayloadUnionTableOffset {}
pub enum SyncMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SyncMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SyncMessage<'a> {
    type Inner = SyncMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SyncMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SyncMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SyncMessageArgs) -> flatbuffers::WIPOffset<SyncMessage<'bldr>> {
      let mut builder = SyncMessageBuilder::new(_fbb);
      if let Some(x) = args.payload { builder.add_payload(x); }
      builder.add_payload_type(args.payload_type);
      builder.finish()
    }

    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn payload_type(&self) -> SyncPayload {
    self._tab.get::<SyncPayload>(SyncMessage::VT_PAYLOAD_TYPE, Some(SyncPayload::NONE)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SyncMessage::VT_PAYLOAD, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_headers(&self) -> Option<GetHeaders<'a>> {
    if self.payload_type() == SyncPayload::GetHeaders {
      self.payload().map(|u| GetHeaders::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_headers(&self) -> Option<Headers<'a>> {
    if self.payload_type() == SyncPayload::Headers {
      self.payload().map(|u| Headers::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct SyncMessageArgs {
    pub payload_type: SyncPayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SyncMessageArgs {
    #[inline]
    fn default() -> Self {
        SyncMessageArgs {
            payload_type: SyncPayload::NONE,
            payload: None,
        }
    }
}
pub struct SyncMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SyncMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: SyncPayload) {
    self.fbb_.push_slot::<SyncPayload>(SyncMessage::VT_PAYLOAD_TYPE, payload_type, SyncPayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SyncMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SyncMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SyncMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SyncMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BytesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Bytes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bytes<'a> {
    type Inner = Bytes<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Bytes<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Bytes {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BytesArgs<'args>) -> flatbuffers::WIPOffset<Bytes<'bldr>> {
      let mut builder = BytesBuilder::new(_fbb);
      if let Some(x) = args.seq { builder.add_seq(x); }
      builder.finish()
    }

    pub const VT_SEQ: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn seq(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Bytes::VT_SEQ, None).map(|v| v.safe_slice())
  }
}

pub struct BytesArgs<'a> {
    pub seq: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for BytesArgs<'a> {
    #[inline]
    fn default() -> Self {
        BytesArgs {
            seq: None,
        }
    }
}
pub struct BytesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BytesBuilder<'a, 'b> {
  #[inline]
  pub fn add_seq(&mut self, seq: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bytes::VT_SEQ, seq);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BytesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BytesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bytes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetHeadersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetHeaders<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetHeaders<'a> {
    type Inner = GetHeaders<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetHeaders<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetHeaders {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetHeadersArgs<'args>) -> flatbuffers::WIPOffset<GetHeaders<'bldr>> {
      let mut builder = GetHeadersBuilder::new(_fbb);
      if let Some(x) = args.hash_stop { builder.add_hash_stop(x); }
      if let Some(x) = args.block_locator_hashes { builder.add_block_locator_hashes(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_BLOCK_LOCATOR_HASHES: flatbuffers::VOffsetT = 6;
    pub const VT_HASH_STOP: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(GetHeaders::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn block_locator_hashes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(GetHeaders::VT_BLOCK_LOCATOR_HASHES, None)
  }
  #[inline]
  pub fn hash_stop(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetHeaders::VT_HASH_STOP, None).map(|v| v.safe_slice())
  }
}

pub struct GetHeadersArgs<'a> {
    pub version: u32,
    pub block_locator_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
    pub hash_stop: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for GetHeadersArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetHeadersArgs {
            version: 0,
            block_locator_hashes: None,
            hash_stop: None,
        }
    }
}
pub struct GetHeadersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetHeadersBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(GetHeaders::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_block_locator_hashes(&mut self, block_locator_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetHeaders::VT_BLOCK_LOCATOR_HASHES, block_locator_hashes);
  }
  #[inline]
  pub fn add_hash_stop(&mut self, hash_stop: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetHeaders::VT_HASH_STOP, hash_stop);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetHeadersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetHeadersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetHeaders<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HeadersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Headers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Headers<'a> {
    type Inner = Headers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Headers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Headers {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeadersArgs<'args>) -> flatbuffers::WIPOffset<Headers<'bldr>> {
      let mut builder = HeadersBuilder::new(_fbb);
      if let Some(x) = args.headers { builder.add_headers(x); }
      builder.finish()
    }

    pub const VT_HEADERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Header<'a>>>>>(Headers::VT_HEADERS, None)
  }
}

pub struct HeadersArgs<'a> {
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Header<'a >>>>>,
}
impl<'a> Default for HeadersArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeadersArgs {
            headers: None,
        }
    }
}
pub struct HeadersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeadersBuilder<'a, 'b> {
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Header<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Headers::VT_HEADERS, headers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeadersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeadersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Headers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Header<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
    type Inner = Header<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Header<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Header {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeaderArgs<'args>) -> flatbuffers::WIPOffset<Header<'bldr>> {
      let mut builder = HeaderBuilder::new(_fbb);
      builder.add_nonce(args.nonce);
      builder.add_number(args.number);
      builder.add_timestamp(args.timestamp);
      if let Some(x) = args.uncles_hash { builder.add_uncles_hash(x); }
      if let Some(x) = args.cellbase_id { builder.add_cellbase_id(x); }
      if let Some(x) = args.proof { builder.add_proof(x); }
      if let Some(x) = args.difficulty { builder.add_difficulty(x); }
      if let Some(x) = args.txs_proposal { builder.add_txs_proposal(x); }
      if let Some(x) = args.txs_commit { builder.add_txs_commit(x); }
      if let Some(x) = args.parent_hash { builder.add_parent_hash(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_PARENT_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 8;
    pub const VT_NUMBER: flatbuffers::VOffsetT = 10;
    pub const VT_TXS_COMMIT: flatbuffers::VOffsetT = 12;
    pub const VT_TXS_PROPOSAL: flatbuffers::VOffsetT = 14;
    pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 16;
    pub const VT_NONCE: flatbuffers::VOffsetT = 18;
    pub const VT_PROOF: flatbuffers::VOffsetT = 20;
    pub const VT_CELLBASE_ID: flatbuffers::VOffsetT = 22;
    pub const VT_UNCLES_HASH: flatbuffers::VOffsetT = 24;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Header::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn parent_hash(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Header::VT_PARENT_HASH, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    self._tab.get::<u64>(Header::VT_TIMESTAMP, Some(0)).unwrap()
  }
  #[inline]
  pub fn number(&self) -> u64 {
    self._tab.get::<u64>(Header::VT_NUMBER, Some(0)).unwrap()
  }
  #[inline]
  pub fn txs_commit(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Header::VT_TXS_COMMIT, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn txs_proposal(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Header::VT_TXS_PROPOSAL, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn difficulty(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Header::VT_DIFFICULTY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(Header::VT_NONCE, Some(0)).unwrap()
  }
  #[inline]
  pub fn proof(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Header::VT_PROOF, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn cellbase_id(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Header::VT_CELLBASE_ID, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn uncles_hash(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Header::VT_UNCLES_HASH, None).map(|v| v.safe_slice())
  }
}

pub struct HeaderArgs<'a> {
    pub version: u32,
    pub parent_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub timestamp: u64,
    pub number: u64,
    pub txs_commit: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub txs_proposal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub difficulty: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub nonce: u64,
    pub proof: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub cellbase_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub uncles_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for HeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeaderArgs {
            version: 0,
            parent_hash: None,
            timestamp: 0,
            number: 0,
            txs_commit: None,
            txs_proposal: None,
            difficulty: None,
            nonce: 0,
            proof: None,
            cellbase_id: None,
            uncles_hash: None,
        }
    }
}
pub struct HeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Header::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_parent_hash(&mut self, parent_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_PARENT_HASH, parent_hash);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_number(&mut self, number: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_NUMBER, number, 0);
  }
  #[inline]
  pub fn add_txs_commit(&mut self, txs_commit: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_TXS_COMMIT, txs_commit);
  }
  #[inline]
  pub fn add_txs_proposal(&mut self, txs_proposal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_TXS_PROPOSAL, txs_proposal);
  }
  #[inline]
  pub fn add_difficulty(&mut self, difficulty: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_DIFFICULTY, difficulty);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn add_proof(&mut self, proof: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_PROOF, proof);
  }
  #[inline]
  pub fn add_cellbase_id(&mut self, cellbase_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_CELLBASE_ID, cellbase_id);
  }
  #[inline]
  pub fn add_uncles_hash(&mut self, uncles_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_UNCLES_HASH, uncles_hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Block<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Block<'a> {
    type Inner = Block<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Block<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Block {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockArgs<'args>) -> flatbuffers::WIPOffset<Block<'bldr>> {
      let mut builder = BlockBuilder::new(_fbb);
      if let Some(x) = args.transactions { builder.add_transactions(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSACTIONS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(Block::VT_HEADER, None)
  }
  #[inline]
  pub fn transactions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Transaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>>>(Block::VT_TRANSACTIONS, None)
  }
}

pub struct BlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Transaction<'a >>>>>,
}
impl<'a> Default for BlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockArgs {
            header: None,
            transactions: None,
        }
    }
}
pub struct BlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(Block::VT_HEADER, header);
  }
  #[inline]
  pub fn add_transactions(&mut self, transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Transaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_TRANSACTIONS, transactions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TransactionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Transaction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Transaction<'a> {
    type Inner = Transaction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Transaction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Transaction {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransactionArgs<'args>) -> flatbuffers::WIPOffset<Transaction<'bldr>> {
      let mut builder = TransactionBuilder::new(_fbb);
      if let Some(x) = args.outputs { builder.add_outputs(x); }
      if let Some(x) = args.inputs { builder.add_inputs(x); }
      if let Some(x) = args.deps { builder.add_deps(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_DEPS: flatbuffers::VOffsetT = 6;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 8;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Transaction::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn deps(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutPoint<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<OutPoint<'a>>>>>(Transaction::VT_DEPS, None)
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CellInput<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CellInput<'a>>>>>(Transaction::VT_INPUTS, None)
  }
  #[inline]
  pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CellOutput<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CellOutput<'a>>>>>(Transaction::VT_OUTPUTS, None)
  }
}

pub struct TransactionArgs<'a> {
    pub version: u32,
    pub deps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<OutPoint<'a >>>>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CellInput<'a >>>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CellOutput<'a >>>>>,
}
impl<'a> Default for TransactionArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransactionArgs {
            version: 0,
            deps: None,
            inputs: None,
            outputs: None,
        }
    }
}
pub struct TransactionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransactionBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Transaction::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_deps(&mut self, deps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OutPoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_DEPS, deps);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CellInput<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CellOutput<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransactionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Transaction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OutPointOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct OutPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutPoint<'a> {
    type Inner = OutPoint<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> OutPoint<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OutPoint {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OutPointArgs<'args>) -> flatbuffers::WIPOffset<OutPoint<'bldr>> {
      let mut builder = OutPointBuilder::new(_fbb);
      builder.add_index(args.index);
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_INDEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn hash(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(OutPoint::VT_HASH, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn index(&self) -> u32 {
    self._tab.get::<u32>(OutPoint::VT_INDEX, Some(0)).unwrap()
  }
}

pub struct OutPointArgs<'a> {
    pub hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub index: u32,
}
impl<'a> Default for OutPointArgs<'a> {
    #[inline]
    fn default() -> Self {
        OutPointArgs {
            hash: None,
            index: 0,
        }
    }
}
pub struct OutPointBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OutPointBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutPoint::VT_HASH, hash);
  }
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(OutPoint::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OutPointBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OutPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OutPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CellInputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CellInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CellInput<'a> {
    type Inner = CellInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CellInput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CellInput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CellInputArgs<'args>) -> flatbuffers::WIPOffset<CellInput<'bldr>> {
      let mut builder = CellInputBuilder::new(_fbb);
      if let Some(x) = args.unlock { builder.add_unlock(x); }
      builder.add_index(args.index);
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_INDEX: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCK: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn hash(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CellInput::VT_HASH, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn index(&self) -> u32 {
    self._tab.get::<u32>(CellInput::VT_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn unlock(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CellInput::VT_UNLOCK, None).map(|v| v.safe_slice())
  }
}

pub struct CellInputArgs<'a> {
    pub hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub index: u32,
    pub unlock: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for CellInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        CellInputArgs {
            hash: None,
            index: 0,
            unlock: None,
        }
    }
}
pub struct CellInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CellInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CellInput::VT_HASH, hash);
  }
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(CellInput::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_unlock(&mut self, unlock: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CellInput::VT_UNLOCK, unlock);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CellInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CellInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CellInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CellOutputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CellOutput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CellOutput<'a> {
    type Inner = CellOutput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CellOutput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CellOutput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CellOutputArgs<'args>) -> flatbuffers::WIPOffset<CellOutput<'bldr>> {
      let mut builder = CellOutputBuilder::new(_fbb);
      builder.add_capacity(args.capacity);
      if let Some(x) = args.lock { builder.add_lock(x); }
      if let Some(x) = args.data { builder.add_data(x); }
      builder.finish()
    }

    pub const VT_CAPACITY: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;
    pub const VT_LOCK: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn capacity(&self) -> u64 {
    self._tab.get::<u64>(CellOutput::VT_CAPACITY, Some(0)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CellOutput::VT_DATA, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn lock(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CellOutput::VT_LOCK, None).map(|v| v.safe_slice())
  }
}

pub struct CellOutputArgs<'a> {
    pub capacity: u64,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub lock: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for CellOutputArgs<'a> {
    #[inline]
    fn default() -> Self {
        CellOutputArgs {
            capacity: 0,
            data: None,
            lock: None,
        }
    }
}
pub struct CellOutputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CellOutputBuilder<'a, 'b> {
  #[inline]
  pub fn add_capacity(&mut self, capacity: u64) {
    self.fbb_.push_slot::<u64>(CellOutput::VT_CAPACITY, capacity, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CellOutput::VT_DATA, data);
  }
  #[inline]
  pub fn add_lock(&mut self, lock: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CellOutput::VT_LOCK, lock);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CellOutputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CellOutputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CellOutput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

