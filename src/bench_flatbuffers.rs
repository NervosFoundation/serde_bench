// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum SyncPayload {
    NONE = 0,
    GetHeaders = 1,
    Headers = 2,
}

const ENUM_MIN_SYNC_PAYLOAD: u8 = 0;
const ENUM_MAX_SYNC_PAYLOAD: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for SyncPayload {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for SyncPayload {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const SyncPayload;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const SyncPayload;
        unsafe { *p }
    }
}

impl flatbuffers::Push for SyncPayload {
    type Output = SyncPayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<SyncPayload>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_SYNC_PAYLOAD: [SyncPayload; 3] = [
    SyncPayload::NONE,
    SyncPayload::GetHeaders,
    SyncPayload::Headers,
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_SYNC_PAYLOAD: [&'static str; 3] = ["NONE", "GetHeaders", "Headers"];

pub fn enum_name_sync_payload(e: SyncPayload) -> &'static str {
    let index: usize = e as usize;
    ENUM_NAMES_SYNC_PAYLOAD[index]
}

pub struct SyncPayloadUnionTableOffset {}
pub enum SyncMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SyncMessage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SyncMessage<'a> {
    type Inner = SyncMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SyncMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SyncMessage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SyncMessageArgs,
    ) -> flatbuffers::WIPOffset<SyncMessage<'bldr>> {
        let mut builder = SyncMessageBuilder::new(_fbb);
        if let Some(x) = args.payload {
            builder.add_payload(x);
        }
        builder.add_payload_type(args.payload_type);
        builder.finish()
    }

    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn payload_type(&self) -> SyncPayload {
        self._tab
            .get::<SyncPayload>(SyncMessage::VT_PAYLOAD_TYPE, Some(SyncPayload::NONE))
            .unwrap()
    }
    #[inline]
    pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                SyncMessage::VT_PAYLOAD,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_get_headers(&'a self) -> Option<GetHeaders> {
        if self.payload_type() == SyncPayload::GetHeaders {
            self.payload().map(|u| GetHeaders::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_headers(&'a self) -> Option<Headers> {
        if self.payload_type() == SyncPayload::Headers {
            self.payload().map(|u| Headers::init_from_table(u))
        } else {
            None
        }
    }
}

pub struct SyncMessageArgs {
    pub payload_type: SyncPayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SyncMessageArgs {
    #[inline]
    fn default() -> Self {
        SyncMessageArgs {
            payload_type: SyncPayload::NONE,
            payload: None,
        }
    }
}
pub struct SyncMessageBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SyncMessageBuilder<'a, 'b> {
    #[inline]
    pub fn add_payload_type(&mut self, payload_type: SyncPayload) {
        self.fbb_.push_slot::<SyncPayload>(
            SyncMessage::VT_PAYLOAD_TYPE,
            payload_type,
            SyncPayload::NONE,
        );
    }
    #[inline]
    pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SyncMessage::VT_PAYLOAD, payload);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SyncMessageBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SyncMessageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SyncMessage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum BytesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Bytes<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bytes<'a> {
    type Inner = Bytes<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Bytes<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Bytes { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BytesArgs<'args>,
    ) -> flatbuffers::WIPOffset<Bytes<'bldr>> {
        let mut builder = BytesBuilder::new(_fbb);
        if let Some(x) = args.seq {
            builder.add_seq(x);
        }
        builder.finish()
    }

    pub const VT_SEQ: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn seq(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Bytes::VT_SEQ, None)
            .map(|v| v.safe_slice())
    }
}

pub struct BytesArgs<'a> {
    pub seq: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BytesArgs<'a> {
    #[inline]
    fn default() -> Self {
        BytesArgs { seq: None }
    }
}
pub struct BytesBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BytesBuilder<'a, 'b> {
    #[inline]
    pub fn add_seq(&mut self, seq: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Bytes::VT_SEQ, seq);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BytesBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BytesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Bytes<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum GetHeadersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetHeaders<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetHeaders<'a> {
    type Inner = GetHeaders<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetHeaders<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetHeaders { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetHeadersArgs<'args>,
    ) -> flatbuffers::WIPOffset<GetHeaders<'bldr>> {
        let mut builder = GetHeadersBuilder::new(_fbb);
        if let Some(x) = args.hash_stop {
            builder.add_hash_stop(x);
        }
        if let Some(x) = args.block_locator_hashes {
            builder.add_block_locator_hashes(x);
        }
        builder.add_version(args.version);
        builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_BLOCK_LOCATOR_HASHES: flatbuffers::VOffsetT = 6;
    pub const VT_HASH_STOP: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn version(&self) -> u32 {
        self._tab
            .get::<u32>(GetHeaders::VT_VERSION, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn block_locator_hashes(
        &self,
    ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>,
        >>(GetHeaders::VT_BLOCK_LOCATOR_HASHES, None)
    }
    #[inline]
    pub fn hash_stop(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                GetHeaders::VT_HASH_STOP,
                None,
            ).map(|v| v.safe_slice())
    }
}

pub struct GetHeadersArgs<'a> {
    pub version: u32,
    pub block_locator_hashes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bytes<'a>>>>,
    >,
    pub hash_stop: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for GetHeadersArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetHeadersArgs {
            version: 0,
            block_locator_hashes: None,
            hash_stop: None,
        }
    }
}
pub struct GetHeadersBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetHeadersBuilder<'a, 'b> {
    #[inline]
    pub fn add_version(&mut self, version: u32) {
        self.fbb_
            .push_slot::<u32>(GetHeaders::VT_VERSION, version, 0);
    }
    #[inline]
    pub fn add_block_locator_hashes(
        &mut self,
        block_locator_hashes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Bytes<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            GetHeaders::VT_BLOCK_LOCATOR_HASHES,
            block_locator_hashes,
        );
    }
    #[inline]
    pub fn add_hash_stop(
        &mut self,
        hash_stop: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(GetHeaders::VT_HASH_STOP, hash_stop);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetHeadersBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GetHeadersBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GetHeaders<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum HeadersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Headers<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Headers<'a> {
    type Inner = Headers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Headers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Headers { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeadersArgs<'args>,
    ) -> flatbuffers::WIPOffset<Headers<'bldr>> {
        let mut builder = HeadersBuilder::new(_fbb);
        if let Some(x) = args.headers {
            builder.add_headers(x);
        }
        builder.finish()
    }

    pub const VT_HEADERS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn headers(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Header<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Header<'a>>>,
        >>(Headers::VT_HEADERS, None)
    }
}

pub struct HeadersArgs<'a> {
    pub headers: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>>,
    >,
}
impl<'a> Default for HeadersArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeadersArgs { headers: None }
    }
}
pub struct HeadersBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeadersBuilder<'a, 'b> {
    #[inline]
    pub fn add_headers(
        &mut self,
        headers: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Header<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Headers::VT_HEADERS, headers);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeadersBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HeadersBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Headers<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum HeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Header<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
    type Inner = Header<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Header<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Header { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeaderArgs<'args>,
    ) -> flatbuffers::WIPOffset<Header<'bldr>> {
        let mut builder = HeaderBuilder::new(_fbb);
        builder.add_nonce(args.nonce);
        builder.add_number(args.number);
        builder.add_timestamp(args.timestamp);
        if let Some(x) = args.uncles_hash {
            builder.add_uncles_hash(x);
        }
        if let Some(x) = args.cellbase_id {
            builder.add_cellbase_id(x);
        }
        if let Some(x) = args.proof {
            builder.add_proof(x);
        }
        if let Some(x) = args.difficulty {
            builder.add_difficulty(x);
        }
        if let Some(x) = args.txs_proposal {
            builder.add_txs_proposal(x);
        }
        if let Some(x) = args.txs_commit {
            builder.add_txs_commit(x);
        }
        if let Some(x) = args.parent_hash {
            builder.add_parent_hash(x);
        }
        builder.add_version(args.version);
        builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_PARENT_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 8;
    pub const VT_NUMBER: flatbuffers::VOffsetT = 10;
    pub const VT_TXS_COMMIT: flatbuffers::VOffsetT = 12;
    pub const VT_TXS_PROPOSAL: flatbuffers::VOffsetT = 14;
    pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 16;
    pub const VT_NONCE: flatbuffers::VOffsetT = 18;
    pub const VT_PROOF: flatbuffers::VOffsetT = 20;
    pub const VT_CELLBASE_ID: flatbuffers::VOffsetT = 22;
    pub const VT_UNCLES_HASH: flatbuffers::VOffsetT = 24;

    #[inline]
    pub fn version(&self) -> u32 {
        self._tab.get::<u32>(Header::VT_VERSION, Some(0)).unwrap()
    }
    #[inline]
    pub fn parent_hash(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Header::VT_PARENT_HASH,
                None,
            ).map(|v| v.safe_slice())
    }
    #[inline]
    pub fn timestamp(&self) -> u64 {
        self._tab.get::<u64>(Header::VT_TIMESTAMP, Some(0)).unwrap()
    }
    #[inline]
    pub fn number(&self) -> u64 {
        self._tab.get::<u64>(Header::VT_NUMBER, Some(0)).unwrap()
    }
    #[inline]
    pub fn txs_commit(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Header::VT_TXS_COMMIT,
                None,
            ).map(|v| v.safe_slice())
    }
    #[inline]
    pub fn txs_proposal(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Header::VT_TXS_PROPOSAL,
                None,
            ).map(|v| v.safe_slice())
    }
    #[inline]
    pub fn difficulty(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Header::VT_DIFFICULTY,
                None,
            ).map(|v| v.safe_slice())
    }
    #[inline]
    pub fn nonce(&self) -> u64 {
        self._tab.get::<u64>(Header::VT_NONCE, Some(0)).unwrap()
    }
    #[inline]
    pub fn proof(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Header::VT_PROOF,
                None,
            ).map(|v| v.safe_slice())
    }
    #[inline]
    pub fn cellbase_id(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Header::VT_CELLBASE_ID,
                None,
            ).map(|v| v.safe_slice())
    }
    #[inline]
    pub fn uncles_hash(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Header::VT_UNCLES_HASH,
                None,
            ).map(|v| v.safe_slice())
    }
}

pub struct HeaderArgs<'a> {
    pub version: u32,
    pub parent_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub timestamp: u64,
    pub number: u64,
    pub txs_commit: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub txs_proposal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub difficulty: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub nonce: u64,
    pub proof: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub cellbase_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub uncles_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for HeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeaderArgs {
            version: 0,
            parent_hash: None,
            timestamp: 0,
            number: 0,
            txs_commit: None,
            txs_proposal: None,
            difficulty: None,
            nonce: 0,
            proof: None,
            cellbase_id: None,
            uncles_hash: None,
        }
    }
}
pub struct HeaderBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeaderBuilder<'a, 'b> {
    #[inline]
    pub fn add_version(&mut self, version: u32) {
        self.fbb_.push_slot::<u32>(Header::VT_VERSION, version, 0);
    }
    #[inline]
    pub fn add_parent_hash(
        &mut self,
        parent_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_PARENT_HASH, parent_hash);
    }
    #[inline]
    pub fn add_timestamp(&mut self, timestamp: u64) {
        self.fbb_
            .push_slot::<u64>(Header::VT_TIMESTAMP, timestamp, 0);
    }
    #[inline]
    pub fn add_number(&mut self, number: u64) {
        self.fbb_.push_slot::<u64>(Header::VT_NUMBER, number, 0);
    }
    #[inline]
    pub fn add_txs_commit(
        &mut self,
        txs_commit: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_TXS_COMMIT, txs_commit);
    }
    #[inline]
    pub fn add_txs_proposal(
        &mut self,
        txs_proposal: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_TXS_PROPOSAL, txs_proposal);
    }
    #[inline]
    pub fn add_difficulty(
        &mut self,
        difficulty: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_DIFFICULTY, difficulty);
    }
    #[inline]
    pub fn add_nonce(&mut self, nonce: u64) {
        self.fbb_.push_slot::<u64>(Header::VT_NONCE, nonce, 0);
    }
    #[inline]
    pub fn add_proof(&mut self, proof: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_PROOF, proof);
    }
    #[inline]
    pub fn add_cellbase_id(
        &mut self,
        cellbase_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_CELLBASE_ID, cellbase_id);
    }
    #[inline]
    pub fn add_uncles_hash(
        &mut self,
        uncles_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_UNCLES_HASH, uncles_hash);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeaderBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HeaderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}
